<!DOCTYPE html>
<html lang="en">

<head>
    <title>Assignment - 3</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <script src="index.js"></script>
    <style>
        .header {
            font-size: 4rem;
            font-weight: bold;
            background: linear-gradient(45deg, #F59E0B, #F472B6);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            animation: glow 1.5s ease-in-out infinite alternate;
        }

        @keyframes glow {
            0% {
                text-shadow: 0 0 1px #F59E0B, 0 0 3px #F59E0B, 0 0 5px #F59E0B;
            }

            100% {
                text-shadow: 0 0 3px #F59E0B, 0 0 5px #F59E0B, 0 0 7px #F59E0B;
            }
        }
                    button {
 align-items: center;
 background-image: linear-gradient(144deg,#AF40FF, #5B42F3 50%,#00DDEB);
 border: 0;
 border-radius: 10px;
 box-shadow: rgba(151, 65, 252, 0.2) 0 15px 30px -5px;
 box-sizing: border-box;
 color: #FFFFFF;
 display: flex;
 font-family: Phantomsans, sans-serif;
 font-size: 18px;
 justify-content: center;
 line-height: 1em;
 max-width: 100%;
 min-width: 140px;
 padding: 3px;
 text-decoration: none;
 user-select: none;
 -webkit-user-select: none;
 touch-action: manipulation;
 white-space: nowrap;
 cursor: pointer;
 transition: all .3s;
 margin-right:20px
}

button:active,
button:hover {
 outline: 0;
}

button span {
 background-color: rgb(5, 6, 45);
 padding: 16px 24px;
 border-radius: 6px;
 width: 100%;
 height: 100%;
 transition: 300ms;
}

button:hover span {
 background: none;
}

button:active {
 transform: scale(0.9);
}
        .glowing-neon {
            text-shadow: 0 0 5px #8e2de2, 0 0 10px #8e2de2, 0 0 15px #8e2de2, 0 0 20px #8e2de2, 0 0 25px #8e2de2, 0 0 30px #8e2de2, 0 0 35px #8e2de2;
            animation: glow 1.5s ease-in-out infinite alternate;
        }

        @keyframes glow {
            0% {
                text-shadow: 0 0 5px #8e2de2, 0 0 10px #8e2de2, 0 0 15px #8e2de2, 0 0 20px #8e2de2, 0 0 25px #8e2de2, 0 0 30px #8e2de2, 0 0 35px #8e2de2;
            }
            100% {
                text-shadow: 0 0 10px #8e2de2, 0 0 20px #8e2de2, 0 0 30px #8e2de2, 0 0 40px #8e2de2, 0 0 50px #8e2de2, 0 0 60px #8e2de2, 0 0 70px #8e2de2;
            }
        }

    
            /* Custom CSS for glowing effect */
        .glowing-container {
            background: radial-gradient(circle, #8e2de2 0%, transparent 70%);
            background-size: 150% 150%;
            animation: glow 1.5s ease-in-out infinite alternate;
        }

        @keyframes glow {
            0% {
                background-position: 0% 0%;
            }
            100% {
                background-position: 100% 100%;
            }
        }

        .custom-bg-rgb {
    background-color: rgb(40, 40, 43);
}

    </style>
</head>

<body class="font-poppins text-xl custom-bg-rgb text-white">
    <header class="text-white py-4 flex justify-between items-center">
        <h1 class="text-3xl font-bold text-center flex-grow glowing-neon">Assignment - 3</h1>
        <button onclick="homepage()"><span class="text">Home</span></button>
    </header>

    <section class="container mx-auto p-4 bg-white shadow-lg rounded-lg mt-8 text-gray-800 bg-opacity-90 glowing-container">
        <h2 class="text-2xl font-semibold mb-2 text-blue-500">Implementation</h2>
        <p class="mb-4 text-white">The code provided below implements the N-queens problem in Python using a backtracking approach:
        </p>
        <pre class="bg-gray-200 p-4 rounded-md">
            <code class="block text-sm">
def solve_n_queens(N):
    def is_safe(board, row, col):
        for i in range(row):
            if board[i][col] == 'Q':
                return False
        
        i, j = row, col
        while i >= 0 and j >= 0:
            if board[i][j] == 'Q':
                return False
            i -= 1
            j -= 1
        
        i, j = row, col
        while i >= 0 and j < N:
            if board[i][j] == 'Q':
                return False
            i -= 1
            j += 1
        
        return True
    
    def solve(row):
        if row == N:
            solutions.append([''.join(row) for row in board])
            return
        
        for col in range(N):
            if is_safe(board, row, col):
                board[row][col] = 'Q'
                solve(row + 1)
                board[row][col] = '.'  # Backtrack
    
    board = [['.' for _ in range(N)] for _ in range(N)]
    solutions = []
    solve(0)
    return solutions

def print_solutions(solutions):
    for i, solution in enumerate(solutions):
        print(f"Solution {i + 1}:")
        for row in solution:
            print(row)
        print("\n")

solutions = solve_n_queens(N)
print_solutions(solutions)
            </code>
        </pre>
    </section>

    <section class="container mx-auto p-4 bg-white shadow-lg rounded-lg mt-8 text-gray-800 bg-opacity-90 glowing-container">
        <h2 class="text-2xl font-semibold mb-2 text-blue-500">Example Input/Output</h2>
        <p class="mb-4 text-white">When a value N is passed as input into the above code we print a chessboard layout with 'Q' as
            safe places and other positions as '.'</p>
        <pre class="bg-gray-200 p-4 rounded-md">
            <code class="block text-sm">
# Example usage:
N = 4

Solution 1:
.Q..
...Q
Q...
..Q.

Solution 2:
..Q.
Q...
...Q
.Q..
            </code>
        </pre>
    </section>

    <section class="container mx-auto p-4 bg-white shadow-lg rounded-lg mt-8 text-gray-800 bg-opacity-90  glowing-container">
        <h2 class="text-2xl font-semibold mb-2 text-blue-500">Time Complexity</h2>
        <p class="mb-4 text-white">The time complexity of the N-Queens problem solver is typically exponential, O(N!), as it
            explores all possible combinations of queen placements on the board. However, due to the pruning effect of
            the backtracking algorithm, the actual number of recursive calls and computations is much lower in practice,
            making it suitable for small chessboard sizes.</p>
    </section>

    <section class="container mx-auto p-4 bg-white shadow-lg rounded-lg mt-8 text-gray-800 bg-opacity-90  glowing-container">
        <h2 class="text-2xl font-semibold mb-2 text-blue-500">Scenarios</h2>
        <p class="text-white"><strong>Efficiency:</strong> Inefficient for large values of N.</p>
        <p class="text-white"><strong>Scenarios:</strong> Suitable for small chessboard sizes, educational purposes,
            or exploring backtracking algorithms.</p>
    </section>

    <script src="index.js"></script>

</body>

</html>